name: Build, Push & Deploy to OpenShift (on PR merge)

on:
  pull_request:
    branches:
      - dev
      - main
      - feature/auto-deployment
    types: [closed]

permissions:
  contents: read
  packages: write
    
jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: [self-hosted]

    env:
      
      REGISTRY: ghcr.io
      IMAGE_OWNER: ibm-oss-support        
      IMAGE_NAME: slack-bot           
   
    steps:
      - name: Clean workspace
        run: |
          echo "Cleaning workspace..."
          rm -rf * .??* || true

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Decide which branch we DEPLOY FOR (base branch of the merged PR)
      - name: Determine target branch & env
        id: cfg
        shell: bash
        run: |
          BRANCH="${{ github.event.pull_request.base.ref }}"
          echo "Deploying for branch: $BRANCH"

          case "$BRANCH" in
            main)
              NS="llm"
              DEPLOY_DIR="deploy-prod"
              VERSION_KEY="version_main"
              ;;
            dev|feature/auto-deployment)
              NS=$([[ "$BRANCH" == "dev" ]] && echo "dev" || echo "test")
              DEPLOY_DIR="deploy-dev"     # or set to deploy-test if you maintain separate files
              VERSION_KEY="version_dev"
              ;;
            *)
              echo "Unsupported base branch: $BRANCH"
              exit 1
              ;;
          esac

          echo "namespace=$NS" >> "$GITHUB_OUTPUT"
          echo "deploy_dir=$DEPLOY_DIR" >> "$GITHUB_OUTPUT"
          echo "version_key=$VERSION_KEY" >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Read version
        id: version
        shell: bash
        run: |
          if [[ ! -f version.txt ]]; then
            echo "version.txt not found"; exit 1
          fi
          KEY="${{ steps.cfg.outputs.version_key }}"
          VERSION=$(awk -v k="$KEY" '$1==k":" {print $2}' version.txt)
          if [[ -z "$VERSION" ]]; then
            echo "Could not read $KEY from version.txt"; exit 1
          fi
          echo "tag=$VERSION" >> "$GITHUB_OUTPUT"
          echo "IMAGE_FULL=${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:$VERSION" >> "$GITHUB_ENV"
          echo "Building tag: $VERSION"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:$VERSION"

      - name: Write CA cert to file
        run: printf '%s' "${{ secrets.OCP_CA_CERT }}" > /tmp/ca.crt

      - name: Log in to OpenShift
        run: |
          oc login \
            --server="${{ secrets.OCP_SERVER }}" \
            --token="${{ secrets.OCP_TOKEN }}" \
            --certificate-authority=/tmp/ca.crt
          oc project "${{ steps.cfg.outputs.namespace }}"

      - name: Login to GHCR (Podman)
        run: |
          echo "${{ secrets.GHCR_PAT }}" | podman login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin

      - name: Build image 
        run: |
         
          podman build --pull=always -t "$IMAGE_FULL" . > /tmp/build.log 2>&1 || {
            echo "Build failed:"; cat /tmp/build.log; exit 1;
          }

      - name: Push image
        run: |
          podman push "$IMAGE_FULL" >> /tmp/push.log 2>&1 || {
            echo "Push failed"; cat /tmp/push.log; exit 1;
          }

      - name: Replace tokens in manifests
        run: |
          cd "${{ steps.cfg.outputs.deploy_dir }}"
          echo "Replacing __VERSION__ -> '${{ steps.version.outputs.tag }}'"
          echo "Replacing __REGISTRY_PATH__ -> '${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}'"
          # Linux vs macOS sed handling
          if sed --version >/dev/null 2>&1; then
            find . -type f -name '*.yaml' -exec sed -i \
              -e "s|__VERSION__|${{ steps.version.outputs.tag }}|g" \
              -e "s|__REGISTRY_PATH__|${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}|g" {} +
          else
            find . -type f -name '*.yaml' -exec sed -i '' \
              -e "s|__VERSION__|${{ steps.version.outputs.tag }}|g" \
              -e "s|__REGISTRY_PATH__|${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}|g" {} +
          fi

      - name: Validate (dry-run)
        run: |
          cd "${{ steps.cfg.outputs.deploy_dir }}"
          for f in *.yaml; do
            echo "Validating $f"
            oc apply --dry-run=client -f "$f" >> /tmp/deploy.log 2>&1 || {
              echo "Validation failed: $f"
              cat /tmp/deploy.log
              exit 1
            }
          done

      - name: Apply manifests
        run: |
          echo "Applying manifests in ${{ steps.cfg.outputs.deploy_dir }}"
          oc apply -f "${{ steps.cfg.outputs.deploy_dir }}" >> /tmp/deploy.log 2>&1 || {
            echo "Apply failed"
            cat /tmp/deploy.log
            exit 1
          }

      - name: Wait for rollout
        run: |
          # adjust 'slack-bot' if your Deployment metadata.name differs
          oc rollout status deployment/slack-bot -n "${{ steps.cfg.outputs.namespace }}" >> /tmp/rollout.log 2>&1 || {
            echo "Rollout failed"; cat /tmp/rollout.log; exit 1;
          }

      - name: Upload logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-deploy-logs
          path: |
            /tmp/build.log
            /tmp/push.log
            /tmp/deploy.log
            /tmp/rollout.log
